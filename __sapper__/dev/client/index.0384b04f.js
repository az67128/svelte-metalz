import { S as SvelteComponentDev, i as init, s as safe_not_equal, E as svg_element, h as claim_element, j as children, l as detach, u as attr, m as add_location, n as insert, o as append, v as noop, F as derived, D as writable, c as create_slot, e as element, G as listen, g as get_slot_changes, a as get_slot_context, t as transition_in, b as transition_out, q as space, f as text, k as claim_text, x as mount_component, p as set_data, z as destroy_component, H as validate_store, I as subscribe, J as now, K as loop, L as run_all, B as group_outros, C as check_outros, r as empty, M as set_style, N as afterUpdate, O as binding_callbacks, P as update_keyed_each, Q as outro_and_destroy_block, R as toggle_class, T as add_render_callback, U as create_bidirectional_transition, V as destroy_block } from './chunk.9be27b5f.js';

/* src/assets/LeftArrowIcon.svelte generated by Svelte v3.6.7 */

const file = "src/assets/LeftArrowIcon.svelte";

function create_fragment(ctx) {
	var svg, g, path;

	return {
		c: function create() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { width: true, viewBox: true, transform: true, fill: true }, true);
			var svg_nodes = children(svg);

			g = claim_element(svg_nodes, "g", {}, true);
			var g_nodes = children(g);

			path = claim_element(g_nodes, "path", { d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			g_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "d", "M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5\n      c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z\n      ");
			add_location(path, file, 6, 4, 137);
			add_location(g, file, 5, 2, 129);
			attr(svg, "width", "24");
			attr(svg, "viewBox", "0 0 477.175 477.175");
			attr(svg, "transform", "rotate(180)");
			attr(svg, "fill", ctx.fill);
			add_location(svg, file, 4, 0, 49);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},

		p: function update(changed, ctx) {
			if (changed.fill) {
				attr(svg, "fill", ctx.fill);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { fill = "black" } = $$props;

	const writable_props = ['fill'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<LeftArrowIcon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('fill' in $$props) $$invalidate('fill', fill = $$props.fill);
	};

	return { fill };
}

class LeftArrowIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["fill"]);
	}

	get fill() {
		throw new Error("<LeftArrowIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<LeftArrowIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/assets/RightArrowIcon.svelte generated by Svelte v3.6.7 */

const file$1 = "src/assets/RightArrowIcon.svelte";

function create_fragment$1(ctx) {
	var svg, g, path;

	return {
		c: function create() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { width: true, viewBox: true, fill: true }, true);
			var svg_nodes = children(svg);

			g = claim_element(svg_nodes, "g", {}, true);
			var g_nodes = children(g);

			path = claim_element(g_nodes, "path", { d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			g_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "d", "M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5\n      c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z\n      ");
			add_location(path, file$1, 6, 4, 113);
			add_location(g, file$1, 5, 2, 105);
			attr(svg, "width", "24");
			attr(svg, "viewBox", "0 0 477.175 477.175");
			attr(svg, "fill", ctx.fill);
			add_location(svg, file$1, 4, 0, 49);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},

		p: function update(changed, ctx) {
			if (changed.fill) {
				attr(svg, "fill", ctx.fill);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { fill = "black" } = $$props;

	const writable_props = ['fill'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<RightArrowIcon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('fill' in $$props) $$invalidate('fill', fill = $$props.fill);
	};

	return { fill };
}

class RightArrowIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["fill"]);
	}

	get fill() {
		throw new Error("<RightArrowIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<RightArrowIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

(function(self) {

var irrelevant = (function (exports) {
  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  return exports;

}({}));
})(typeof self !== 'undefined' ? self : commonjsGlobal);

const serverUrl = 'https://metalz.herokuapp.com';
const spiritOfMetalUrl = 'https://www.spirit-of-metal.com';

function getAlbums(year = new Date().getFullYear(), month = new Date().getMonth() + 1) {
  return fetch(`${serverUrl}?year=${year}&month=${month}`)
    .then(data => data.json())
    .then(res => res.body);
}

const isLoading = writable(false);
const hasError = writable(false);
const coverPreviewSrc = writable(null);
const filterYandex = writable(false);
const filterGoogle = writable(false);
const sortByAphabet = writable(false);
const showGenreDialog = writable(false);

const selectedGenres = (() => {
  const { subscribe, set, update } = writable([]);
  return {
    subscribe,
    toggle: genre =>
      update(genres => {
        if (genres.some(item => item === genre)) {
          return genres.filter(item => item !== genre);
        } else {
          return [...genres, genre];
        }
      }),
    reset: () => set([]),
  };
})();

const albums = (() => {
  const { subscribe, set, update } = writable([]);
  return {
    subscribe,
    get: (year, month) => {
      isLoading.set(true);
      getAlbums(year, month)
        .then(data => set(data))
        .catch(err => hasError.set(true))
        .finally(() => isLoading.set(false));
    },
  };
})();

const currentMonth = (() => {
  const { subscribe, set, update } = writable(new Date());
  return {
    subscribe,
    nextMonth: () =>
      update(date => {
        return new Date(date.setMonth(date.getMonth() + 1));
      }),
    prevMonth: () =>
      update(date => {
        return new Date(date.setMonth(date.getMonth() - 1));
      }),
  };
})();


currentMonth.subscribe(value => {
  albums.get(value.getFullYear(), value.getMonth() + 1);
});

const sortedAlbums = derived(
  [albums, filterYandex, filterGoogle, sortByAphabet, selectedGenres],
  ([$albums, $filterYandex, $filterGoogle, $sortByAphabet, $selectedGenres]) => {
    return $albums
      .filter(album => {
        const yandex = $filterYandex ? !!album.yandex_link : true;
        const google = $filterGoogle ? !!album.google_link : true;

        const genre =
          $selectedGenres.length > 0
            ? $selectedGenres.some(
                item => album.genre.toLowerCase().indexOf(item.toLowerCase()) > -1
              )
            : true;
        return yandex && google && genre;
      })
      .sort((a, b) => {
        if ($sortByAphabet) {
          return a.title < b.title ? -1 : 1;
        } else {
          return a.listeners < b.listeners ? 1 : -1;
        }
      });
  }
);

function getLang() {
  // if (navigator.languages != undefined) return navigator.languages[0];
  // else return navigator.language;
  return 'en-US';
}
const lang = getLang();
const translation = {
  month: {
    'ru-RU': ['ЯНВ', 'ФЕВ', 'МАР', 'АПР', 'МАЙ', 'ИЮН', 'ИЮЛ', 'АВГ', 'СЕН', 'ОКТ', 'НОЯ', 'ДЕК'],
    'en-US': ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEN', 'OCT', 'NOV', 'DEC'],
  },
  genreSelectTitle: {
    'ru-RU': 'ВЫБЕРИТЕ ЖАНРЫ',
    'en-US': 'SELECT GENRES',
  },
};

function translate(text) {
  return translation[text][lang] ? translation[text][lang] : translation[text]['en-US'];
}

/* src/components/IconButton.svelte generated by Svelte v3.6.7 */

const file$2 = "src/components/IconButton.svelte";

function create_fragment$2(ctx) {
	var button, current, dispose;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c: function create() {
			button = element("button");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			if (default_slot) default_slot.l(button_nodes);
			button_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(button, "class", "button svelte-9l5ek4");
			add_location(button, file$2, 22, 0, 315);
			dispose = listen(button, "click", ctx.onClick);
		},

		m: function mount(target, anchor) {
			insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(button);
			}

			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { onClick = () => {} } = $$props;

	const writable_props = ['onClick'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<IconButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('onClick' in $$props) $$invalidate('onClick', onClick = $$props.onClick);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { onClick, $$slots, $$scope };
}

class IconButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["onClick"]);
	}

	get onClick() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onClick(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Header.svelte generated by Svelte v3.6.7 */

const file$3 = "src/components/Header.svelte";

// (28:2) <IconButton onClick={currentMonth.prevMonth}>
function create_default_slot_1(ctx) {
	var current;

	var leftarrowicon = new LeftArrowIcon({ $$inline: true });

	return {
		c: function create() {
			leftarrowicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			leftarrowicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(leftarrowicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(leftarrowicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(leftarrowicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(leftarrowicon, detaching);
		}
	};
}

// (34:2) <IconButton onClick={currentMonth.nextMonth}>
function create_default_slot(ctx) {
	var current;

	var rightarrowicon = new RightArrowIcon({ $$inline: true });

	return {
		c: function create() {
			rightarrowicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			rightarrowicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(rightarrowicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(rightarrowicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(rightarrowicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(rightarrowicon, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	var header, t0, div, t1_value = translate('month')[ctx.$currentMonth.getMonth()], t1, t2_value = ' ', t2, t3_value = ctx.$currentMonth.getFullYear(), t3, t4, current;

	var iconbutton0 = new IconButton({
		props: {
		onClick: currentMonth.prevMonth,
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var iconbutton1 = new IconButton({
		props: {
		onClick: currentMonth.nextMonth,
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			header = element("header");
			iconbutton0.$$.fragment.c();
			t0 = space();
			div = element("div");
			t1 = text(t1_value);
			t2 = text(t2_value);
			t3 = text(t3_value);
			t4 = space();
			iconbutton1.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true }, false);
			var header_nodes = children(header);

			iconbutton0.$$.fragment.l(header_nodes);
			t0 = claim_text(header_nodes, "\n  ");

			div = claim_element(header_nodes, "DIV", {}, false);
			var div_nodes = children(div);

			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_text(div_nodes, t2_value);
			t3 = claim_text(div_nodes, t3_value);
			div_nodes.forEach(detach);
			t4 = claim_text(header_nodes, "\n  ");
			iconbutton1.$$.fragment.l(header_nodes);
			header_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(div, file$3, 30, 2, 743);
			attr(header, "class", "svelte-a1ecao");
			add_location(header, file$3, 25, 0, 645);
		},

		m: function mount(target, anchor) {
			insert(target, header, anchor);
			mount_component(iconbutton0, header, null);
			append(header, t0);
			append(header, div);
			append(div, t1);
			append(div, t2);
			append(div, t3);
			append(header, t4);
			mount_component(iconbutton1, header, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var iconbutton0_changes = {};
			if (changed.currentMonth) iconbutton0_changes.onClick = currentMonth.prevMonth;
			if (changed.$$scope) iconbutton0_changes.$$scope = { changed, ctx };
			iconbutton0.$set(iconbutton0_changes);

			if ((!current || changed.$currentMonth) && t1_value !== (t1_value = translate('month')[ctx.$currentMonth.getMonth()])) {
				set_data(t1, t1_value);
			}

			if ((!current || changed.$currentMonth) && t3_value !== (t3_value = ctx.$currentMonth.getFullYear())) {
				set_data(t3, t3_value);
			}

			var iconbutton1_changes = {};
			if (changed.currentMonth) iconbutton1_changes.onClick = currentMonth.nextMonth;
			if (changed.$$scope) iconbutton1_changes.$$scope = { changed, ctx };
			iconbutton1.$set(iconbutton1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton0.$$.fragment, local);

			transition_in(iconbutton1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(iconbutton0.$$.fragment, local);
			transition_out(iconbutton1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(header);
			}

			destroy_component(iconbutton0, );

			destroy_component(iconbutton1, );
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $currentMonth;

	validate_store(currentMonth, 'currentMonth');
	subscribe($$self, currentMonth, $$value => { $currentMonth = $$value; $$invalidate('$currentMonth', $currentMonth); });

	return { $currentMonth };
}

class Header extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, []);
	}
}

/* src/assets/YandexIcon.svelte generated by Svelte v3.6.7 */

const file$4 = "src/assets/YandexIcon.svelte";

function create_fragment$4(ctx) {
	var svg, path0, path1;

	return {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { viewBox: true, width: true, fill: true }, true);
			var svg_nodes = children(svg);

			path0 = claim_element(svg_nodes, "path", { d: true }, true);
			var path0_nodes = children(path0);

			path0_nodes.forEach(detach);

			path1 = claim_element(svg_nodes, "path", { d: true }, true);
			var path1_nodes = children(path1);

			path1_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path0, "d", "m208.464844 400\n    53.222656-117.585938h23.515625v117.585938h33.414063v-315h-59.171876c-37.664062\n    0-82.539062 39.609375-82.539062 103.964844 0 64.367187 56.3125 90.355468\n    56.3125 90.355468l-66.835938\n    120.679688zm20.636718-160.847656c-8.222656-10.332032-15.382812-27.523438-15.382812-56.058594\n    0-62.507812 35.941406-70.582031\n    40.898438-71.394531.355468-.058594.703124-.078125\n    1.058593-.078125h28.59375v142.945312h-22.246093c-12.71875\n    0-25-5.464844-32.921876-15.414062zm0 0");
			add_location(path0, file$4, 5, 2, 97);
			attr(path1, "d", "m0 0v485h485v-485zm455 455h-425v-425h425zm0 0");
			add_location(path1, file$4, 15, 2, 617);
			attr(svg, "viewBox", "0 0 485 485");
			attr(svg, "width", "24");
			attr(svg, "fill", ctx.fill);
			add_location(svg, file$4, 4, 0, 49);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},

		p: function update(changed, ctx) {
			if (changed.fill) {
				attr(svg, "fill", ctx.fill);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { fill = "black" } = $$props;

	const writable_props = ['fill'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<YandexIcon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('fill' in $$props) $$invalidate('fill', fill = $$props.fill);
	};

	return { fill };
}

class YandexIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["fill"]);
	}

	get fill() {
		throw new Error("<YandexIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<YandexIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/assets/GoogleIcon.svelte generated by Svelte v3.6.7 */

const file$5 = "src/assets/GoogleIcon.svelte";

function create_fragment$5(ctx) {
	var svg, g1, g0, path;

	return {
		c: function create() {
			svg = svg_element("svg");
			g1 = svg_element("g");
			g0 = svg_element("g");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { width: true, viewBox: true, fill: true }, true);
			var svg_nodes = children(svg);

			g1 = claim_element(svg_nodes, "g", { transform: true }, true);
			var g1_nodes = children(g1);

			g0 = claim_element(g1_nodes, "g", {}, true);
			var g0_nodes = children(g0);

			path = claim_element(g0_nodes, "path", { d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			g0_nodes.forEach(detach);
			g1_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "d", "M473.702,235.076L368.699,174.33c-0.563-0.281-1.149-0.487-1.747-0.635L265.431,115.32L40.672-0.097\n        c-0.85-0.34-1.7-0.577-2.538-0.717c-0.913-0.205-1.861-0.24-2.826-0.084c-1.209,0.139-2.35,0.514-3.38,1.121\n        c-2.845,1.211-4.273,4.346-4.273,7.489v494.644c0,3.471,1.736,6.075,4.339,7.81c0.868,0.868,2.603,0.868,4.339,0.868\n        s2.603,0,4.339-0.868l224.759-124.963l98.788-57.281c0.048,0.001,0.092,0.006,0.141,0.006c1.736,0,2.603-0.868,4.339-2.603l0,0\n        c0.757-0.253,1.43-0.664,2.019-1.168l102.985-59.578c5.207-2.603,8.678-8.678,8.678-14.753S478.909,238.547,473.702,235.076z\n        M45.011,27.672l238.522,222.91L45.011,481.154V27.672z\n        M350.475,183.876L320.2,214.639l-23.569,23.871l-104.529-97.156\n        L88.484,44.644l168.269,85.429L350.475,183.876z\n        M256.753,370.452l-166.75,91.97L248.075,309.62l48.557-46.736l53.359,54.043\n        L256.753,370.452z\n        M365.817,307.633l-56.21-56.931l56.531-57.256l98.887,57.25L365.817,307.633z");
			add_location(path, file$5, 7, 6, 150);
			add_location(g0, file$5, 6, 4, 140);
			attr(g1, "transform", "translate(1 1)");
			add_location(g1, file$5, 5, 2, 105);
			attr(svg, "width", "24");
			attr(svg, "viewBox", "0 0 512.035 512.035");
			attr(svg, "fill", ctx.fill);
			add_location(svg, file$5, 4, 0, 49);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g1);
			append(g1, g0);
			append(g0, path);
		},

		p: function update(changed, ctx) {
			if (changed.fill) {
				attr(svg, "fill", ctx.fill);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { fill = "black" } = $$props;

	const writable_props = ['fill'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<GoogleIcon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('fill' in $$props) $$invalidate('fill', fill = $$props.fill);
	};

	return { fill };
}

class GoogleIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["fill"]);
	}

	get fill() {
		throw new Error("<GoogleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<GoogleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/assets/GuitarIcon.svelte generated by Svelte v3.6.7 */

const file$6 = "src/assets/GuitarIcon.svelte";

function create_fragment$6(ctx) {
	var svg, g1, g0, path;

	return {
		c: function create() {
			svg = svg_element("svg");
			g1 = svg_element("g");
			g0 = svg_element("g");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { width: true, fill: true, viewBox: true }, true);
			var svg_nodes = children(svg);

			g1 = claim_element(svg_nodes, "g", {}, true);
			var g1_nodes = children(g1);

			g0 = claim_element(g1_nodes, "g", {}, true);
			var g0_nodes = children(g0);

			path = claim_element(g0_nodes, "path", { d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			g0_nodes.forEach(detach);
			g1_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "d", "M44.812,438.499c72.248,66.792,155.854,33.166,155.854,33.166S178.86,334.45,304.26,337.176\n        c0,0-7.273-24.534,19.998-58.168l-4.096-4.092c0,0-33.166,34.083-65.434,28.181c-21.78-3.987-16.417-23.492-10.782-36.447\n        l129.61-131.652c12.828-11.071,29.37-13.395,38.992-5.176c-0.673-13.187,5.414-28.427,17.524-40.541\n        c12.712-12.706,28.842-18.751,42.467-17.34l9.137-9.135l-1.378-27.966l-2.886-2.879c-1.026,3.078-2.545,6.233-4.652,9.279\n        c-7.39,10.654-18.507,15.733-24.83,11.343c-3.903-2.711-5.054-8.383-3.643-14.829c-6.448,1.406-12.119,0.26-14.836-3.643\n        c-4.384-6.328,0.697-17.444,11.349-24.832c3.042-2.112,6.2-3.625,9.273-4.652l-1.683-1.691l-28.253-1.386l-10.547,10.549\n        c0.204,12.868-5.843,27.475-17.549,39.174c-11.71,11.696-26.305,17.751-39.177,17.545l-0.705,0.705\n        c7.942,9.989,5.121,26.904-6.633,39.653L220.113,236.549c-6.344,3.228-13.337,5.642-18.542,4.292\n        c-12.269-3.178-40.892-4.544,34.534-107.229l-4.089-4.089c0,0-46.805,36.802-75.426,37.257c0,0,11.356,125.862-147.219,117.229\n        C9.378,284.009-27.432,371.712,44.812,438.499z");
			add_location(path, file$6, 7, 6, 123);
			add_location(g0, file$6, 6, 4, 113);
			add_location(g1, file$6, 5, 2, 105);
			attr(svg, "width", "24");
			attr(svg, "fill", ctx.fill);
			attr(svg, "viewBox", "0 0 481.677 481.678");
			add_location(svg, file$6, 4, 0, 49);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g1);
			append(g1, g0);
			append(g0, path);
		},

		p: function update(changed, ctx) {
			if (changed.fill) {
				attr(svg, "fill", ctx.fill);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { fill = "black" } = $$props;

	const writable_props = ['fill'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<GuitarIcon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('fill' in $$props) $$invalidate('fill', fill = $$props.fill);
	};

	return { fill };
}

class GuitarIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["fill"]);
	}

	get fill() {
		throw new Error("<GuitarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<GuitarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Footer.svelte generated by Svelte v3.6.7 */

const file$7 = "src/components/Footer.svelte";

// (38:2) <IconButton onClick={() => showGenreDialog.update(state => !state)}>
function create_default_slot_3(ctx) {
	var current;

	var guitaricon = new GuitarIcon({
		props: { fill: ctx.$selectedGenres.length > 0 ? '#b2102f' : 'white' },
		$$inline: true
	});

	return {
		c: function create() {
			guitaricon.$$.fragment.c();
		},

		l: function claim(nodes) {
			guitaricon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(guitaricon, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var guitaricon_changes = {};
			if (changed.$selectedGenres) guitaricon_changes.fill = ctx.$selectedGenres.length > 0 ? '#b2102f' : 'white';
			guitaricon.$set(guitaricon_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(guitaricon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(guitaricon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(guitaricon, detaching);
		}
	};
}

// (42:2) <IconButton onClick={() => filterYandex.update(state => !state)}>
function create_default_slot_2(ctx) {
	var current;

	var yandexicon = new YandexIcon({
		props: { fill: ctx.$filterYandex ? '#b2102f' : 'white' },
		$$inline: true
	});

	return {
		c: function create() {
			yandexicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			yandexicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(yandexicon, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var yandexicon_changes = {};
			if (changed.$filterYandex) yandexicon_changes.fill = ctx.$filterYandex ? '#b2102f' : 'white';
			yandexicon.$set(yandexicon_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(yandexicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(yandexicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(yandexicon, detaching);
		}
	};
}

// (45:2) <IconButton onClick={() => filterGoogle.update(state => !state)}>
function create_default_slot_1$1(ctx) {
	var current;

	var googleicon = new GoogleIcon({
		props: { fill: ctx.$filterGoogle ? '#b2102f' : 'white' },
		$$inline: true
	});

	return {
		c: function create() {
			googleicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			googleicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(googleicon, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var googleicon_changes = {};
			if (changed.$filterGoogle) googleicon_changes.fill = ctx.$filterGoogle ? '#b2102f' : 'white';
			googleicon.$set(googleicon_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(googleicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(googleicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(googleicon, detaching);
		}
	};
}

// (49:4) <IconButton onClick={() => sortByAphabet.update(state => !state)}>
function create_default_slot$1(ctx) {
	var t_value = ctx.$sortByAphabet ? 'AZ' : '321', t;

	return {
		c: function create() {
			t = text(t_value);
		},

		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},

		m: function mount(target, anchor) {
			insert(target, t, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.$sortByAphabet) && t_value !== (t_value = ctx.$sortByAphabet ? 'AZ' : '321')) {
				set_data(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

function create_fragment$7(ctx) {
	var footer, t0, t1, t2, div, current;

	var iconbutton0 = new IconButton({
		props: {
		onClick: ctx.func,
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var iconbutton1 = new IconButton({
		props: {
		onClick: ctx.func_1,
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var iconbutton2 = new IconButton({
		props: {
		onClick: ctx.func_2,
		$$slots: { default: [create_default_slot_1$1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var iconbutton3 = new IconButton({
		props: {
		onClick: ctx.func_3,
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			footer = element("footer");
			iconbutton0.$$.fragment.c();
			t0 = space();
			iconbutton1.$$.fragment.c();
			t1 = space();
			iconbutton2.$$.fragment.c();
			t2 = space();
			div = element("div");
			iconbutton3.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true }, false);
			var footer_nodes = children(footer);

			iconbutton0.$$.fragment.l(footer_nodes);
			t0 = claim_text(footer_nodes, "\n  ");
			iconbutton1.$$.fragment.l(footer_nodes);
			t1 = claim_text(footer_nodes, "\n  ");
			iconbutton2.$$.fragment.l(footer_nodes);
			t2 = claim_text(footer_nodes, "\n  ");

			div = claim_element(footer_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			iconbutton3.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach);
			footer_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div, "class", "sortButton svelte-1vyyi6d");
			add_location(div, file$7, 47, 2, 1270);
			attr(footer, "class", "svelte-1vyyi6d");
			add_location(footer, file$7, 36, 0, 804);
		},

		m: function mount(target, anchor) {
			insert(target, footer, anchor);
			mount_component(iconbutton0, footer, null);
			append(footer, t0);
			mount_component(iconbutton1, footer, null);
			append(footer, t1);
			mount_component(iconbutton2, footer, null);
			append(footer, t2);
			append(footer, div);
			mount_component(iconbutton3, div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var iconbutton0_changes = {};
			if (changed.showGenreDialog) iconbutton0_changes.onClick = ctx.func;
			if (changed.$$scope || changed.$selectedGenres) iconbutton0_changes.$$scope = { changed, ctx };
			iconbutton0.$set(iconbutton0_changes);

			var iconbutton1_changes = {};
			if (changed.filterYandex) iconbutton1_changes.onClick = ctx.func_1;
			if (changed.$$scope || changed.$filterYandex) iconbutton1_changes.$$scope = { changed, ctx };
			iconbutton1.$set(iconbutton1_changes);

			var iconbutton2_changes = {};
			if (changed.filterGoogle) iconbutton2_changes.onClick = ctx.func_2;
			if (changed.$$scope || changed.$filterGoogle) iconbutton2_changes.$$scope = { changed, ctx };
			iconbutton2.$set(iconbutton2_changes);

			var iconbutton3_changes = {};
			if (changed.sortByAphabet) iconbutton3_changes.onClick = ctx.func_3;
			if (changed.$$scope || changed.$sortByAphabet) iconbutton3_changes.$$scope = { changed, ctx };
			iconbutton3.$set(iconbutton3_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton0.$$.fragment, local);

			transition_in(iconbutton1.$$.fragment, local);

			transition_in(iconbutton2.$$.fragment, local);

			transition_in(iconbutton3.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(iconbutton0.$$.fragment, local);
			transition_out(iconbutton1.$$.fragment, local);
			transition_out(iconbutton2.$$.fragment, local);
			transition_out(iconbutton3.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(footer);
			}

			destroy_component(iconbutton0, );

			destroy_component(iconbutton1, );

			destroy_component(iconbutton2, );

			destroy_component(iconbutton3, );
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let $selectedGenres, $filterYandex, $filterGoogle, $sortByAphabet;

	validate_store(selectedGenres, 'selectedGenres');
	subscribe($$self, selectedGenres, $$value => { $selectedGenres = $$value; $$invalidate('$selectedGenres', $selectedGenres); });
	validate_store(filterYandex, 'filterYandex');
	subscribe($$self, filterYandex, $$value => { $filterYandex = $$value; $$invalidate('$filterYandex', $filterYandex); });
	validate_store(filterGoogle, 'filterGoogle');
	subscribe($$self, filterGoogle, $$value => { $filterGoogle = $$value; $$invalidate('$filterGoogle', $filterGoogle); });
	validate_store(sortByAphabet, 'sortByAphabet');
	subscribe($$self, sortByAphabet, $$value => { $sortByAphabet = $$value; $$invalidate('$sortByAphabet', $sortByAphabet); });

	function func() {
		return showGenreDialog.update(state => !state);
	}

	function func_1() {
		return filterYandex.update(state => !state);
	}

	function func_2() {
		return filterGoogle.update(state => !state);
	}

	function func_3() {
		return sortByAphabet.update(state => !state);
	}

	return {
		$selectedGenres,
		$filterYandex,
		$filterGoogle,
		$sortByAphabet,
		func,
		func_1,
		func_2,
		func_3
	};
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, []);
	}
}

function pannable(node) {
  let startX;
  let startY;
  let x;
  let y;

  function handleMousedown(e) {
    const event = e.touches ? e.touches[0] : e;
    x = startX = event.clientX;
    y = startY = event.clientY;

    node.dispatchEvent(
      new CustomEvent('panstart', {
        detail: { x, y },
      })
    );

    window.addEventListener('mousemove', handleMousemove);
    window.addEventListener('touchmove', handleMousemove);
    window.addEventListener('mouseup', handleMouseup);
    window.addEventListener('touchend', handleMouseup);
  }

  function handleMousemove(e) {
    const event = e.touches ? e.touches[0] : e;
    const dx = event.clientX - x;
    const dy = event.clientY - y;
    x = event.clientX;
    y = event.clientY;

    if (Math.abs(event.clientX - startX) < window.innerWidth * 0.15) return;

    node.dispatchEvent(
      new CustomEvent('panmove', {
        detail: { x, y, dx, dy },
      })
    );
  }

  function handleMouseup(e) {
    const event = e.changedTouches ? e.changedTouches[0] : e;

    x = event.clientX;
    y = event.clientY;

    node.dispatchEvent(
      new CustomEvent('panend', {
        detail: { x, y },
      })
    );

    window.removeEventListener('mousemove', handleMousemove);
    window.removeEventListener('touchmove', handleMousemove);
    window.removeEventListener('mouseup', handleMouseup);
    window.removeEventListener('touchend', handleMouseup);
  }

  node.addEventListener('mousedown', handleMousedown);
  node.addEventListener('touchstart', handleMousedown);

  return {
    destroy() {
      node.removeEventListener('mousedown', handleMousedown);
      node.removeEventListener('touchstart', handleMousedown);
    },
  };
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function tick_spring(ctx, last_value, current_value, target_value) {
    if (typeof current_value === 'number' || is_date(current_value)) {
        // @ts-ignore
        const delta = target_value - current_value;
        // @ts-ignore
        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
        const spring = ctx.opts.stiffness * delta;
        const damper = ctx.opts.damping * velocity;
        const acceleration = (spring - damper) * ctx.inv_mass;
        const d = (velocity + acceleration) * ctx.dt;
        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
            return target_value; // settled
        }
        else {
            ctx.settled = false; // signal loop to keep ticking
            // @ts-ignore
            return is_date(current_value) ?
                new Date(current_value.getTime() + d) : current_value + d;
        }
    }
    else if (Array.isArray(current_value)) {
        // @ts-ignore
        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
    }
    else if (typeof current_value === 'object') {
        const next_value = {};
        for (const k in current_value)
            // @ts-ignore
            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
        // @ts-ignore
        return next_value;
    }
    else {
        throw new Error(`Cannot spring ${typeof current_value} values`);
    }
}
function spring(value, opts = {}) {
    const store = writable(value);
    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
    let last_time;
    let task;
    let current_token;
    let last_value = value;
    let target_value = value;
    let inv_mass = 1;
    let inv_mass_recovery_rate = 0;
    let cancel_task = false;
    /* eslint-disable @typescript-eslint/no-use-before-define */
    function set(new_value, opts = {}) {
        target_value = new_value;
        const token = current_token = {};
        if (opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
            cancel_task = true; // cancel any running animation
            last_time = now();
            last_value = value;
            store.set(value = target_value);
            return new Promise(f => f()); // fulfil immediately
        }
        else if (opts.soft) {
            const rate = opts.soft === true ? .5 : +opts.soft;
            inv_mass_recovery_rate = 1 / (rate * 60);
            inv_mass = 0; // infinite mass, unaffected by spring forces
        }
        if (!task) {
            last_time = now();
            cancel_task = false;
            task = loop(now => {
                if (cancel_task) {
                    cancel_task = false;
                    task = null;
                    return false;
                }
                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                const ctx = {
                    inv_mass,
                    opts: spring,
                    settled: true,
                    dt: (now - last_time) * 60 / 1000
                };
                const next_value = tick_spring(ctx, last_value, value, target_value);
                last_time = now;
                last_value = value;
                store.set(value = next_value);
                if (ctx.settled)
                    task = null;
                return !ctx.settled;
            });
        }
        return new Promise(fulfil => {
            task.promise.then(() => {
                if (token === current_token)
                    fulfil();
            });
        });
    }
    /* eslint-enable @typescript-eslint/no-use-before-define */
    const spring = {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe,
        stiffness,
        damping,
        precision
    };
    return spring;
}

/* src/components/Album/Content.svelte generated by Svelte v3.6.7 */

const file$8 = "src/components/Album/Content.svelte";

function create_fragment$8(ctx) {
	var div5, div0, img, t0, div4, div1, t1, t2, div2, t3, t4, div3, t5, dispose;

	return {
		c: function create() {
			div5 = element("div");
			div0 = element("div");
			img = element("img");
			t0 = space();
			div4 = element("div");
			div1 = element("div");
			t1 = text(ctx.author);
			t2 = space();
			div2 = element("div");
			t3 = text(ctx.title);
			t4 = space();
			div3 = element("div");
			t5 = text(ctx.genre);
			this.h();
		},

		l: function claim(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			div0 = claim_element(div5_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t0 = claim_text(div5_nodes, "\n  ");

			div4 = claim_element(div5_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div1 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			t1 = claim_text(div1_nodes, ctx.author);
			div1_nodes.forEach(detach);
			t2 = claim_text(div4_nodes, "\n    ");

			div2 = claim_element(div4_nodes, "DIV", {}, false);
			var div2_nodes = children(div2);

			t3 = claim_text(div2_nodes, ctx.title);
			div2_nodes.forEach(detach);
			t4 = claim_text(div4_nodes, "\n    ");

			div3 = claim_element(div4_nodes, "DIV", {}, false);
			var div3_nodes = children(div3);

			t5 = claim_text(div3_nodes, ctx.genre);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			div5_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(img, "src", ctx.src);
			attr(img, "alt", "album-cover");
			attr(img, "class", "svelte-14jr33o");
			add_location(img, file$8, 45, 4, 929);
			attr(div0, "class", "cover svelte-14jr33o");
			add_location(div0, file$8, 44, 2, 884);
			attr(div1, "class", "albumTitle svelte-14jr33o");
			add_location(div1, file$8, 51, 4, 1160);
			add_location(div2, file$8, 52, 4, 1203);
			add_location(div3, file$8, 53, 4, 1226);
			attr(div4, "class", "albumInfo svelte-14jr33o");
			add_location(div4, file$8, 50, 2, 1132);
			attr(div5, "class", "content svelte-14jr33o");
			add_location(div5, file$8, 43, 0, 860);

			dispose = [
				listen(img, "error", ctx.error_handler),
				listen(div0, "click", ctx.viewCover)
			];
		},

		m: function mount(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div0);
			append(div0, img);
			append(div5, t0);
			append(div5, div4);
			append(div4, div1);
			append(div1, t1);
			append(div4, t2);
			append(div4, div2);
			append(div2, t3);
			append(div4, t4);
			append(div4, div3);
			append(div3, t5);
		},

		p: function update(changed, ctx) {
			if (changed.src) {
				attr(img, "src", ctx.src);
			}

			if (changed.author) {
				set_data(t1, ctx.author);
			}

			if (changed.title) {
				set_data(t3, ctx.title);
			}

			if (changed.genre) {
				set_data(t5, ctx.genre);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(div5);
			}

			run_all(dispose);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	
  let { cover_url, title, author, genre } = $$props;
  let src = `${spiritOfMetalUrl}${cover_url}`;
  const viewCover = () => {
    coverPreviewSrc.set(src);
  };

	const writable_props = ['cover_url', 'title', 'author', 'genre'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Content> was created with unknown prop '${key}'`);
	});

	function error_handler() {
		const $$result = (src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=');
		$$invalidate('src', src);
		return $$result;
	}

	$$self.$set = $$props => {
		if ('cover_url' in $$props) $$invalidate('cover_url', cover_url = $$props.cover_url);
		if ('title' in $$props) $$invalidate('title', title = $$props.title);
		if ('author' in $$props) $$invalidate('author', author = $$props.author);
		if ('genre' in $$props) $$invalidate('genre', genre = $$props.genre);
	};

	return {
		cover_url,
		title,
		author,
		genre,
		src,
		viewCover,
		error_handler
	};
}

class Content extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, ["cover_url", "title", "author", "genre"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.cover_url === undefined && !('cover_url' in props)) {
			console.warn("<Content> was created without expected prop 'cover_url'");
		}
		if (ctx.title === undefined && !('title' in props)) {
			console.warn("<Content> was created without expected prop 'title'");
		}
		if (ctx.author === undefined && !('author' in props)) {
			console.warn("<Content> was created without expected prop 'author'");
		}
		if (ctx.genre === undefined && !('genre' in props)) {
			console.warn("<Content> was created without expected prop 'genre'");
		}
	}

	get cover_url() {
		throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cover_url(value) {
		throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get author() {
		throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set author(value) {
		throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get genre() {
		throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set genre(value) {
		throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/IconLink.svelte generated by Svelte v3.6.7 */

const file$9 = "src/components/IconLink.svelte";

function create_fragment$9(ctx) {
	var a, current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c: function create() {
			a = element("a");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, target: true }, false);
			var a_nodes = children(a);

			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(a, "href", ctx.href);
			attr(a, "target", "_blank");
			add_location(a, file$9, 3, 0, 41);
		},

		m: function mount(target, anchor) {
			insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}

			if (!current || changed.href) {
				attr(a, "href", ctx.href);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(a);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { href = "" } = $$props;

	const writable_props = ['href'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<IconLink> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('href' in $$props) $$invalidate('href', href = $$props.href);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { href, $$slots, $$scope };
}

class IconLink extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, ["href"]);
	}

	get href() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/assets/LastFmIcon.svelte generated by Svelte v3.6.7 */

const file$a = "src/assets/LastFmIcon.svelte";

function create_fragment$a(ctx) {
	var svg, path0, path1;

	return {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { viewBox: true, width: true, fill: true }, true);
			var svg_nodes = children(svg);

			path0 = claim_element(svg_nodes, "path", { d: true }, true);
			var path0_nodes = children(path0);

			path0_nodes.forEach(detach);

			path1 = claim_element(svg_nodes, "path", { d: true }, true);
			var path1_nodes = children(path1);

			path1_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path0, "d", "m256 512c140.960938 0 256-115.050781 256-256\n    0-140.960938-115.050781-256-256-256-140.960938 0-256 115.050781-256 256 0\n    140.960938 115.050781 256 256 256zm0-482c124.617188 0 226 101.382812 226\n    226s-101.382812 226-226 226-226-101.382812-226-226 101.382812-226 226-226zm0\n    0");
			add_location(path0, file$a, 5, 2, 97);
			attr(path1, "d", "m196 361c28.046875 0 54.414062-10.921875\n    74.246094-30.753906l-21.214844-21.214844c-14.164062 14.167969-33\n    21.96875-53.03125 21.96875-41.355469 0-75-33.644531-75-75s33.644531-75\n    75-75c45.558594 0 60.523438 33.144531 79.757812 87.730469 7.554688 21.445312\n    15.367188 43.621093 27.179688 60.570312 14.65625 21.035157 34.191406\n    31.699219 58.0625 31.699219 33.085938 0 60-26.914062 60-60\n    0-31.613281-24.574219-57.59375-55.625-59.84375v-.15625h-4.375c-16.542969\n    0-30-13.457031-30-30s13.457031-30 30-30 30 13.457031 30\n    30h30c0-33.085938-26.914062-60-60-60s-60 26.914062-60 60c0 32.648438\n    26.210938 59.289062 58.691406 59.984375l1.308594.015625c16.542969 0 30\n    13.457031 30 30s-13.457031 30-30 30c-29.976562\n    0-41.167969-27.449219-56.949219-72.238281-16.914062-48.011719-37.964843-107.761719-108.050781-107.761719-57.898438\n    0-105 47.101562-105 105s47.101562 105 105 105zm0 0");
			add_location(path1, file$a, 11, 2, 403);
			attr(svg, "viewBox", "0 0 512 512");
			attr(svg, "width", "24");
			attr(svg, "fill", ctx.fill);
			add_location(svg, file$a, 4, 0, 49);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},

		p: function update(changed, ctx) {
			if (changed.fill) {
				attr(svg, "fill", ctx.fill);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { fill = "black" } = $$props;

	const writable_props = ['fill'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<LastFmIcon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('fill' in $$props) $$invalidate('fill', fill = $$props.fill);
	};

	return { fill };
}

class LastFmIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, ["fill"]);
	}

	get fill() {
		throw new Error("<LastFmIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<LastFmIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Album/Footer.svelte generated by Svelte v3.6.7 */

const file$b = "src/components/Album/Footer.svelte";

// (31:0) {#if listeners}
function create_if_block(ctx) {
	var div3, div1, t0, div0, t1_value = ctx.listeners.toLocaleString(), t1, t2, div2, t3, current;

	var iconlink = new IconLink({
		props: {
		href: ctx.lastfm_url,
		$$slots: { default: [create_default_slot_2$1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var if_block0 = (ctx.yandex_link) && create_if_block_2(ctx);

	var if_block1 = (ctx.google_link) && create_if_block_1(ctx);

	return {
		c: function create() {
			div3 = element("div");
			div1 = element("div");
			iconlink.$$.fragment.c();
			t0 = space();
			div0 = element("div");
			t1 = text(t1_value);
			t2 = space();
			div2 = element("div");
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},

		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			div1 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			iconlink.$$.fragment.l(div1_nodes);
			t0 = claim_text(div1_nodes, "\n      ");

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			t1 = claim_text(div0_nodes, t1_value);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t2 = claim_text(div3_nodes, "\n\n    ");

			div2 = claim_element(div3_nodes, "DIV", {}, false);
			var div2_nodes = children(div2);

			if (if_block0) if_block0.l(div2_nodes);
			t3 = claim_text(div2_nodes, "\n      ");
			if (if_block1) if_block1.l(div2_nodes);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "class", "svelte-1ob30ti");
			add_location(div0, file$b, 37, 6, 828);
			attr(div1, "class", "lastFmContainer svelte-1ob30ti");
			add_location(div1, file$b, 33, 4, 716);
			add_location(div2, file$b, 40, 4, 884);
			attr(div3, "class", "footer svelte-1ob30ti");
			add_location(div3, file$b, 31, 2, 690);
		},

		m: function mount(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			mount_component(iconlink, div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, t1);
			append(div3, t2);
			append(div3, div2);
			if (if_block0) if_block0.m(div2, null);
			append(div2, t3);
			if (if_block1) if_block1.m(div2, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var iconlink_changes = {};
			if (changed.lastfm_url) iconlink_changes.href = ctx.lastfm_url;
			if (changed.$$scope) iconlink_changes.$$scope = { changed, ctx };
			iconlink.$set(iconlink_changes);

			if ((!current || changed.listeners) && t1_value !== (t1_value = ctx.listeners.toLocaleString())) {
				set_data(t1, t1_value);
			}

			if (ctx.yandex_link) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div2, t3);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			if (ctx.google_link) {
				if (if_block1) {
					if_block1.p(changed, ctx);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, null);
				}
			} else if (if_block1) {
				group_outros();
				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconlink.$$.fragment, local);

			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},

		o: function outro(local) {
			transition_out(iconlink.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div3);
			}

			destroy_component(iconlink, );

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (35:6) <IconLink href={lastfm_url}>
function create_default_slot_2$1(ctx) {
	var current;

	var lastfmicon = new LastFmIcon({ $$inline: true });

	return {
		c: function create() {
			lastfmicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			lastfmicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(lastfmicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(lastfmicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(lastfmicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(lastfmicon, detaching);
		}
	};
}

// (42:6) {#if yandex_link}
function create_if_block_2(ctx) {
	var current;

	var iconlink = new IconLink({
		props: {
		href: `https://music.yandex.ru/album/${ctx.yandex_link}`,
		$$slots: { default: [create_default_slot_1$2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			iconlink.$$.fragment.c();
		},

		l: function claim(nodes) {
			iconlink.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(iconlink, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var iconlink_changes = {};
			if (changed.yandex_link) iconlink_changes.href = `https://music.yandex.ru/album/${ctx.yandex_link}`;
			if (changed.$$scope) iconlink_changes.$$scope = { changed, ctx };
			iconlink.$set(iconlink_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconlink.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(iconlink.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(iconlink, detaching);
		}
	};
}

// (43:8) <IconLink href={`https://music.yandex.ru/album/${yandex_link}`}>
function create_default_slot_1$2(ctx) {
	var current;

	var yandexicon = new YandexIcon({ $$inline: true });

	return {
		c: function create() {
			yandexicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			yandexicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(yandexicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(yandexicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(yandexicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(yandexicon, detaching);
		}
	};
}

// (47:6) {#if google_link}
function create_if_block_1(ctx) {
	var span, current;

	var iconlink = new IconLink({
		props: {
		href: `https://play.google.com/music/m/${ctx.google_link}`,
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			span = element("span");
			iconlink.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			iconlink.$$.fragment.l(span_nodes);
			span_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(span, "class", "googleLink svelte-1ob30ti");
			add_location(span, file$b, 47, 8, 1076);
		},

		m: function mount(target, anchor) {
			insert(target, span, anchor);
			mount_component(iconlink, span, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var iconlink_changes = {};
			if (changed.google_link) iconlink_changes.href = `https://play.google.com/music/m/${ctx.google_link}`;
			if (changed.$$scope) iconlink_changes.$$scope = { changed, ctx };
			iconlink.$set(iconlink_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconlink.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(iconlink.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(span);
			}

			destroy_component(iconlink, );
		}
	};
}

// (49:10) <IconLink href={`https://play.google.com/music/m/${google_link}`}>
function create_default_slot$2(ctx) {
	var current;

	var googleicon = new GoogleIcon({ $$inline: true });

	return {
		c: function create() {
			googleicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			googleicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(googleicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(googleicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(googleicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(googleicon, detaching);
		}
	};
}

function create_fragment$b(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.listeners) && create_if_block(ctx);

	return {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.listeners) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	
  let { listeners = 0, lastfm_url, yandex_link, google_link } = $$props;

	const writable_props = ['listeners', 'lastfm_url', 'yandex_link', 'google_link'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Footer> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('listeners' in $$props) $$invalidate('listeners', listeners = $$props.listeners);
		if ('lastfm_url' in $$props) $$invalidate('lastfm_url', lastfm_url = $$props.lastfm_url);
		if ('yandex_link' in $$props) $$invalidate('yandex_link', yandex_link = $$props.yandex_link);
		if ('google_link' in $$props) $$invalidate('google_link', google_link = $$props.google_link);
	};

	return {
		listeners,
		lastfm_url,
		yandex_link,
		google_link
	};
}

class Footer$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, ["listeners", "lastfm_url", "yandex_link", "google_link"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.lastfm_url === undefined && !('lastfm_url' in props)) {
			console.warn("<Footer> was created without expected prop 'lastfm_url'");
		}
		if (ctx.yandex_link === undefined && !('yandex_link' in props)) {
			console.warn("<Footer> was created without expected prop 'yandex_link'");
		}
		if (ctx.google_link === undefined && !('google_link' in props)) {
			console.warn("<Footer> was created without expected prop 'google_link'");
		}
	}

	get listeners() {
		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listeners(value) {
		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lastfm_url() {
		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lastfm_url(value) {
		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get yandex_link() {
		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set yandex_link(value) {
		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get google_link() {
		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set google_link(value) {
		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Album/index.svelte generated by Svelte v3.6.7 */

const file$c = "src/components/Album/index.svelte";

function create_fragment$c(ctx) {
	var div1, div0, t, current;

	var content = new Content({
		props: {
		cover_url: ctx.cover_url,
		title: ctx.title,
		author: ctx.author,
		genre: ctx.genre
	},
		$$inline: true
	});

	var footer = new Footer$1({
		props: {
		listeners: ctx.listeners,
		lastfm_url: ctx.lastfm_url,
		yandex_link: ctx.yandex_link,
		google_link: ctx.google_link
	},
		$$inline: true
	});

	return {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			content.$$.fragment.c();
			t = space();
			footer.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			content.$$.fragment.l(div0_nodes);
			t = claim_text(div0_nodes, "\n    ");
			footer.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "class", "album svelte-14a7lcl");
			add_location(div0, file$c, 47, 2, 805);
			attr(div1, "class", "wrapper svelte-14a7lcl");
			add_location(div1, file$c, 46, 0, 781);
		},

		m: function mount(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(content, div0, null);
			append(div0, t);
			mount_component(footer, div0, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var content_changes = {};
			if (changed.cover_url) content_changes.cover_url = ctx.cover_url;
			if (changed.title) content_changes.title = ctx.title;
			if (changed.author) content_changes.author = ctx.author;
			if (changed.genre) content_changes.genre = ctx.genre;
			content.$set(content_changes);

			var footer_changes = {};
			if (changed.listeners) footer_changes.listeners = ctx.listeners;
			if (changed.lastfm_url) footer_changes.lastfm_url = ctx.lastfm_url;
			if (changed.yandex_link) footer_changes.yandex_link = ctx.yandex_link;
			if (changed.google_link) footer_changes.google_link = ctx.google_link;
			footer.$set(footer_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(content.$$.fragment, local);

			transition_in(footer.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(content.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div1);
			}

			destroy_component(content, );

			destroy_component(footer, );
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	
  let { album = {} } = $$props;
  const {
    cover_url,
    title,
    author,
    genre,
    listeners,
    lastfm_url,
    yandex_link,
    google_link
  } = album;

	const writable_props = ['album'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('album' in $$props) $$invalidate('album', album = $$props.album);
	};

	return {
		album,
		cover_url,
		title,
		author,
		genre,
		listeners,
		lastfm_url,
		yandex_link,
		google_link
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, ["album"]);
	}

	get album() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set album(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Loader.svelte generated by Svelte v3.6.7 */

const file$d = "src/components/Loader.svelte";

function create_fragment$d(ctx) {
	var div, svg, g, path;

	return {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			svg = claim_element(div_nodes, "svg", { width: true, height: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			g = claim_element(svg_nodes, "g", {}, true);
			var g_nodes = children(g);

			path = claim_element(g_nodes, "path", { d: true, fill: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			g_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "d", "M386.163,48.499L217.807,216.857c-7.646,1.901-15.05,1.533-20.277-3.687c-12.381-12.381,5.53-39.459,14.835-51.738\n        c2.679-3.528,1.751-4.749-2.27-2.877l-36.834,17.142c-4.015,1.872-7.902,6.927-8.846,11.257\n        c-2.914,13.387-9.812,40.158-20.3,50.646c-11.8,11.798-82.429,25.519-106.325,29.892c-4.358,0.781-7.938,4.98-8.299,9.405\n        c-2.96,36.347-21.045,78.954-28.722,95.669c-1.855,4.023-0.254,5.582,3.767,3.719c52.676-24.389,89.847-12.383,98.364-3.859\n        c7.402,7.406-14.757,78.178-22.421,101.781c-1.365,4.207,0.651,5.902,4.554,3.803l72.122-38.932\n        c3.901-2.101,7.801-7.326,8.782-11.65c4.711-20.73,18.372-76.357,32.366-90.355c12.106-12.106,32.801-15.608,44.144-16.639\n        c4.412-0.389,9.78-3.542,11.94-7.405l15.028-26.718c2.176-3.863,1.134-4.729-2.585-2.312c-11.27,7.334-34.737,19.188-50.468,3.455\n        c-6.854-6.854-5.67-18.459-0.974-31.05L405.423,66.358c3.418-2.843,11.95-9.004,19.119-6.083c0,0,27.139-32.226,45.456-31.881\n        c0,0,6.268-14.074,12.034-25.271L387.565,24.32C387.565,24.32,395.488,36.873,386.163,48.499z\n        M155.207,330.984l-9.043,9.037\n        c-3.136,3.134-8.213,3.134-11.353,0l-24.115-24.109c-3.132-3.146-3.132-8.219,0-11.364l9.043-9.037\n        c3.132-3.138,8.209-3.138,11.349,0l24.119,24.108C158.339,322.765,158.339,327.839,155.207,330.984z\n        M191.599,283.235\n        c3.136,3.131,3.136,8.204,0,11.346l-9.041,9.049c-3.132,3.126-8.211,3.126-11.351,0l-24.119-24.121\n        c-3.132-3.126-3.132-8.207,0-11.345l9.047-9.045c3.132-3.138,8.211-3.138,11.351,0l4.027,4.023l18.556,18.562L191.599,283.235z");
			attr(path, "fill", "#b2102f");
			add_location(path, file$d, 31, 6, 599);
			add_location(g, file$d, 30, 4, 589);
			attr(svg, "width", "100");
			attr(svg, "height", "100");
			attr(svg, "viewBox", "0 0 482.032 482.032");
			attr(svg, "class", "svelte-4kvlrp");
			add_location(svg, file$d, 29, 2, 524);
			attr(div, "class", "loader svelte-4kvlrp");
			add_location(div, file$d, 28, 0, 501);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			append(svg, g);
			append(g, path);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

class Loader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$d, safe_not_equal, []);
	}
}

/* src/components/Main.svelte generated by Svelte v3.6.7 */

const file$e = "src/components/Main.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.album = list[i];
	child_ctx.index = i;
	return child_ctx;
}

// (123:4) {:else}
function create_else_block(ctx) {
	var each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

	var each_value = ctx.$sortedAlbums.slice(0, ctx.limit);

	const get_key = ctx => ctx.album.album_id;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c: function create() {
			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(nodes);

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			const each_value = ctx.$sortedAlbums.slice(0, ctx.limit);

			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
			check_outros();
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

// (121:4) {#if $isLoading}
function create_if_block$1(ctx) {
	var current;

	var loader = new Loader({ $$inline: true });

	return {
		c: function create() {
			loader.$$.fragment.c();
		},

		l: function claim(nodes) {
			loader.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

// (126:8) {#if (index + 1) % 5 === 0 || index + 1 === limit}
function create_if_block_1$1(ctx) {
	var span, t, span_index_value;

	return {
		c: function create() {
			span = element("span");
			t = text("intersection\n          ");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { index: true, class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "intersection\n          ");
			span_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(span, "index", span_index_value = ctx.index);
			attr(span, "class", "intersection svelte-vpg4i0");
			add_location(span, file$e, 126, 10, 2774);
		},

		m: function mount(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
			ctx.span_binding(span);
		},

		p: function update(changed, ctx) {
			if ((changed.$sortedAlbums || changed.limit) && span_index_value !== (span_index_value = ctx.index)) {
				attr(span, "index", span_index_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(span);
			}

			ctx.span_binding(null);
		}
	};
}

// (124:6) {#each $sortedAlbums.slice(0, limit) as album, index (album.album_id)}
function create_each_block(key_1, ctx) {
	var first, t, if_block_anchor, current;

	var album = new Index({
		props: { album: ctx.album },
		$$inline: true
	});

	var if_block = ((ctx.index + 1) % 5 === 0 || ctx.index + 1 === ctx.limit) && create_if_block_1$1(ctx);

	return {
		key: key_1,

		first: null,

		c: function create() {
			first = empty();
			album.$$.fragment.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			first = empty();
			album.$$.fragment.l(nodes);
			t = claim_text(nodes, "\n        ");
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			this.first = first;
		},

		m: function mount(target, anchor) {
			insert(target, first, anchor);
			mount_component(album, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var album_changes = {};
			if (changed.$sortedAlbums || changed.limit) album_changes.album = ctx.album;
			album.$set(album_changes);

			if ((ctx.index + 1) % 5 === 0 || ctx.index + 1 === ctx.limit) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(album.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(album.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(first);
			}

			destroy_component(album, detaching);

			if (detaching) {
				detach(t);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

function create_fragment$e(ctx) {
	var main, div, current_block_type_index, if_block, pannable_action, current, dispose;

	var if_block_creators = [
		create_if_block$1,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.$isLoading) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c: function create() {
			main = element("main");
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { class: true }, false);
			var main_nodes = children(main);

			div = claim_element(main_nodes, "DIV", { class: true, style: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach);
			main_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div, "class", "wrapper svelte-vpg4i0");
			set_style(div, "transform", "translate(" + ctx.$coords + "px,0px)");
			add_location(div, file$e, 113, 2, 2366);
			attr(main, "class", "main svelte-vpg4i0");
			add_location(main, file$e, 112, 0, 2322);

			dispose = [
				listen(div, "panstart", ctx.handlePanStart),
				listen(div, "panmove", ctx.handlePanMove),
				listen(div, "panend", ctx.handlePanEnd)
			];
		},

		m: function mount(target, anchor) {
			insert(target, main, anchor);
			append(main, div);
			if_blocks[current_block_type_index].m(div, null);
			pannable_action = pannable.call(null, div) || {};
			ctx.main_binding(main);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if (!current || changed.$coords) {
				set_style(div, "transform", "translate(" + ctx.$coords + "px,0px)");
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(main);
			}

			if_blocks[current_block_type_index].d();
			if (pannable_action && typeof pannable_action.destroy === 'function') pannable_action.destroy();
			ctx.main_binding(null);
			run_all(dispose);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let $coords, $isLoading, $sortedAlbums;

	validate_store(isLoading, 'isLoading');
	subscribe($$self, isLoading, $$value => { $isLoading = $$value; $$invalidate('$isLoading', $isLoading); });
	validate_store(sortedAlbums, 'sortedAlbums');
	subscribe($$self, sortedAlbums, $$value => { $sortedAlbums = $$value; $$invalidate('$sortedAlbums', $sortedAlbums); });

	

  let container;
  const scrollToTop = () => {
    if (container) { container.scrollTop = 0; $$invalidate('container', container); }
  };

  filterYandex.subscribe(scrollToTop);
  filterGoogle.subscribe(scrollToTop);

  // ------------------Pannable
  let startX = 0;
  const coords = spring(0, {
    stiffness: 0.2,
    damping: 0.4
  }); validate_store(coords, 'coords'); subscribe($$self, coords, $$value => { $coords = $$value; $$invalidate('$coords', $coords); });

  function handlePanStart() {
    startX = 0;
    coords.stiffness = coords.damping = 1; $$invalidate('coords', coords);
  }

  function handlePanMove(event) {
    coords.update($coords => $coords + event.detail.dx);
  }

  function handlePanEnd(event) {
    const delta = startX - $coords;

    if (Math.abs(delta) < window.innerWidth / 3) {
      coords.stiffness = 0.2; $$invalidate('coords', coords);
      coords.damping = 0.4; $$invalidate('coords', coords);
      coords.set(0);
      return;
    } else {
      coords.stiffness = 1; $$invalidate('coords', coords);
      coords.damping = 1; $$invalidate('coords', coords);
      coords.set(0);
    }
    coords.set(0);
    if (delta > 0) {
      currentMonth.nextMonth();
    } else {
      currentMonth.prevMonth();
    }
  }
  // ------------------
  let trigger;
  let limit = 11;
  const observer =
    typeof IntersectionObserver !== "undefined"
      ? new IntersectionObserver(
          entries => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                $$invalidate('limit', limit = +entry.target.getAttribute("index") + 10);
              }
            });
          },
          {
            root: document.querySelector(".main"),
            rootMargin: "10px",
            threshold: 0.1
          }
        )
      : null;
  afterUpdate(() => {
    if (trigger) observer.observe(trigger);
  });

	function span_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('trigger', trigger = $$value);
		});
	}

	function main_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('container', container = $$value);
		});
	}

	return {
		container,
		coords,
		handlePanStart,
		handlePanMove,
		handlePanEnd,
		trigger,
		limit,
		$coords,
		$isLoading,
		$sortedAlbums,
		span_binding,
		main_binding
	};
}

class Main extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$e, safe_not_equal, []);
	}
}

function fade(node, { delay = 0, duration = 400 }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

/* src/assets/CloseIcon.svelte generated by Svelte v3.6.7 */

const file$f = "src/assets/CloseIcon.svelte";

function create_fragment$f(ctx) {
	var svg, g, path;

	return {
		c: function create() {
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { width: true, viewBox: true }, true);
			var svg_nodes = children(svg);

			g = claim_element(svg_nodes, "g", {}, true);
			var g_nodes = children(g);

			path = claim_element(g_nodes, "path", { fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			g_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "fill", "#fff");
			attr(path, "d", "M28.941,31.786L0.613,60.114c-0.787,0.787-0.787,2.062,0,2.849c0.393,0.394,0.909,0.59,1.424,0.59\n      c0.516,0,1.031-0.196,1.424-0.59l28.541-28.541l28.541,28.541c0.394,0.394,0.909,0.59,1.424,0.59c0.515,0,1.031-0.196,1.424-0.59\n      c0.787-0.787,0.787-2.062,0-2.849L35.064,31.786L63.41,3.438c0.787-0.787,0.787-2.062,0-2.849c-0.787-0.786-2.062-0.786-2.848,0\n      L32.003,29.15L3.441,0.59c-0.787-0.786-2.061-0.786-2.848,0c-0.787,0.787-0.787,2.062,0,2.849L28.941,31.786z");
			add_location(path, file$f, 2, 4, 47);
			add_location(g, file$f, 1, 2, 39);
			attr(svg, "width", "24");
			attr(svg, "viewBox", "0 0 64 64");
			add_location(svg, file$f, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg);
			}
		}
	};
}

class CloseIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$f, safe_not_equal, []);
	}
}

/* src/components/CoverPreview.svelte generated by Svelte v3.6.7 */

const file$g = "src/components/CoverPreview.svelte";

// (57:0) {#if $coverPreviewSrc}
function create_if_block$2(ctx) {
	var div1, div0, t0, t1, img, img_transition, div1_transition, current, dispose;

	var iconbutton = new IconButton({
		props: {
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	},
		$$inline: true
	});
	iconbutton.$on("click", ctx.close);

	var if_block = (ctx.isLoading) && create_if_block_1$2();

	return {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			iconbutton.$$.fragment.c();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			img = element("img");
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			iconbutton.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach);
			t0 = claim_text(div1_nodes, "\n    ");
			if (if_block) if_block.l(div1_nodes);
			t1 = claim_text(div1_nodes, "\n    ");

			img = claim_element(div1_nodes, "IMG", { src: true, alt: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "class", "close svelte-1bz4ao9");
			add_location(div0, file$g, 61, 4, 1179);
			attr(img, "src", ctx.$coverPreviewSrc);
			attr(img, "alt", "cover-preview");
			attr(img, "class", "svelte-1bz4ao9");
			toggle_class(img, "isLoading", ctx.isLoading);
			add_location(img, file$g, 71, 4, 1381);
			attr(div1, "class", "coverPreview svelte-1bz4ao9");
			add_location(div1, file$g, 57, 2, 1083);

			dispose = [
				listen(img, "load", ctx.load_handler),
				listen(div1, "click", ctx.close)
			];
		},

		m: function mount(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(iconbutton, div0, null);
			append(div1, t0);
			if (if_block) if_block.m(div1, null);
			append(div1, t1);
			append(div1, img);
			current = true;
		},

		p: function update(changed, ctx) {
			var iconbutton_changes = {};
			if (changed.$$scope) iconbutton_changes.$$scope = { changed, ctx };
			iconbutton.$set(iconbutton_changes);

			if (ctx.isLoading) {
				if (!if_block) {
					if_block = create_if_block_1$2();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t1);
				} else {
									transition_in(if_block, 1);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if (!current || changed.$coverPreviewSrc) {
				attr(img, "src", ctx.$coverPreviewSrc);
			}

			if (changed.isLoading) {
				toggle_class(img, "isLoading", ctx.isLoading);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);

			transition_in(if_block);

			add_render_callback(() => {
				if (!img_transition) img_transition = create_bidirectional_transition(img, fly, { duration: 200 }, true);
				img_transition.run(1);
			});

			add_render_callback(() => {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: 200 }, true);
				div1_transition.run(1);
			});

			current = true;
		},

		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			transition_out(if_block);

			if (!img_transition) img_transition = create_bidirectional_transition(img, fly, { duration: 200 }, false);
			img_transition.run(0);

			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: 200 }, false);
			div1_transition.run(0);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div1);
			}

			destroy_component(iconbutton, );

			if (if_block) if_block.d();

			if (detaching) {
				if (img_transition) img_transition.end();
				if (div1_transition) div1_transition.end();
			}

			run_all(dispose);
		}
	};
}

// (63:6) <IconButton on:click={close}>
function create_default_slot$3(ctx) {
	var current;

	var closeicon = new CloseIcon({ $$inline: true });

	return {
		c: function create() {
			closeicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			closeicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(closeicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(closeicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(closeicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(closeicon, detaching);
		}
	};
}

// (67:4) {#if isLoading}
function create_if_block_1$2(ctx) {
	var div, current;

	var loader = new Loader({ $$inline: true });

	return {
		c: function create() {
			div = element("div");
			loader.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			loader.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div, "class", "loader svelte-1bz4ao9");
			add_location(div, file$g, 67, 6, 1314);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(loader, );
		}
	};
}

function create_fragment$g(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.$coverPreviewSrc) && create_if_block$2(ctx);

	return {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.$coverPreviewSrc) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let $coverPreviewSrc;

	validate_store(coverPreviewSrc, 'coverPreviewSrc');
	subscribe($$self, coverPreviewSrc, $$value => { $coverPreviewSrc = $$value; $$invalidate('$coverPreviewSrc', $coverPreviewSrc); });

	

  let isLoading = true;
  const close = () => {
    coverPreviewSrc.set(null);
    $$invalidate('isLoading', isLoading = true);
  };

	function load_handler(e) {
	        isLoading = false; $$invalidate('isLoading', isLoading);
	      }

	return {
		isLoading,
		close,
		$coverPreviewSrc,
		load_handler
	};
}

class CoverPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$g, safe_not_equal, []);
	}
}

const genres = [
  'Alternative',
  'Ambiant',
  'Atmospheric',
  'Black',
  'Brutal',
  'Crossover',
  'Crust',
  'Cyber',
  'Dark',
  'Death',
  'Doom',
  'Drone',
  'Emo',
  'Epic',
  'Experimental',
  'Folk',
  'Fusion',
  'Glam',
  'Gothic',
  'Grind',
  'Grunge',
  'Hardcore',
  'Heavy',
  'Industrial',
  'Jazz',
  'Melodic',
  'Metalcore',
  'Modern',
  'Neo',
  'Noise',
  'Nu',
  'Pagan',
  'Post',
  'Power',
  'Progressive',
  'Rock',
  'Screamo',
  'Sludge',
  'Southern',
  'Speed',
  'Stoner',
  'Symphonic',
  'Technical',
  'Thrash',
  'Viking',
];

/* src/components/GenreDialog.svelte generated by Svelte v3.6.7 */

const file$h = "src/components/GenreDialog.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.genre = list[i];
	child_ctx.index = i;
	return child_ctx;
}

// (65:0) {#if $showGenreDialog}
function create_if_block$3(ctx) {
	var div1, header, t0, div0, t1_value = translate('genreSelectTitle'), t1, t2, button, t3, t4, main, each_blocks = [], each_1_lookup = new Map(), div1_transition, current, dispose;

	var iconbutton = new IconButton({
		props: {
		onClick: ctx.func,
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var each_value = genres;

	const get_key = ctx => ctx.genre;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c: function create() {
			div1 = element("div");
			header = element("header");
			iconbutton.$$.fragment.c();
			t0 = space();
			div0 = element("div");
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			t3 = text("RESET");
			t4 = space();
			main = element("main");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			header = claim_element(div1_nodes, "HEADER", { class: true }, false);
			var header_nodes = children(header);

			iconbutton.$$.fragment.l(header_nodes);
			t0 = claim_text(header_nodes, "\n      ");

			div0 = claim_element(header_nodes, "DIV", {}, false);
			var div0_nodes = children(div0);

			t1 = claim_text(div0_nodes, t1_value);
			div0_nodes.forEach(detach);
			t2 = claim_text(header_nodes, "\n      ");

			button = claim_element(header_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t3 = claim_text(button_nodes, "RESET");
			button_nodes.forEach(detach);
			header_nodes.forEach(detach);
			t4 = claim_text(div1_nodes, "\n    ");

			main = claim_element(div1_nodes, "MAIN", { class: true }, false);
			var main_nodes = children(main);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(main_nodes);

			main_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(div0, file$h, 72, 6, 1572);
			attr(button, "class", "button svelte-j43c0x");
			add_location(button, file$h, 73, 6, 1621);
			attr(header, "class", "svelte-j43c0x");
			add_location(header, file$h, 68, 4, 1449);
			attr(main, "class", "svelte-j43c0x");
			add_location(main, file$h, 75, 4, 1694);
			attr(div1, "class", "genreSelect svelte-j43c0x");
			add_location(div1, file$h, 65, 2, 1353);
			dispose = listen(button, "click", ctx.close);
		},

		m: function mount(target, anchor) {
			insert(target, div1, anchor);
			append(div1, header);
			mount_component(iconbutton, header, null);
			append(header, t0);
			append(header, div0);
			append(div0, t1);
			append(header, t2);
			append(header, button);
			append(button, t3);
			append(div1, t4);
			append(div1, main);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(main, null);

			current = true;
		},

		p: function update(changed, ctx) {
			var iconbutton_changes = {};
			if (changed.showGenreDialog) iconbutton_changes.onClick = ctx.func;
			if (changed.$$scope) iconbutton_changes.$$scope = { changed, ctx };
			iconbutton.$set(iconbutton_changes);

			const each_value = genres;
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, main, destroy_block, create_each_block$1, null, get_each_context$1);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);

			add_render_callback(() => {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, { x: -window.innerWidth, duration: 300 }, true);
				div1_transition.run(1);
			});

			current = true;
		},

		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);

			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, { x: -window.innerWidth, duration: 300 }, false);
			div1_transition.run(0);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div1);
			}

			destroy_component(iconbutton, );

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();

			if (detaching) {
				if (div1_transition) div1_transition.end();
			}

			dispose();
		}
	};
}

// (70:6) <IconButton onClick={() => showGenreDialog.set(false)}>
function create_default_slot$4(ctx) {
	var current;

	var leftarrowicon = new LeftArrowIcon({ $$inline: true });

	return {
		c: function create() {
			leftarrowicon.$$.fragment.c();
		},

		l: function claim(nodes) {
			leftarrowicon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(leftarrowicon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(leftarrowicon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(leftarrowicon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(leftarrowicon, detaching);
		}
	};
}

// (77:6) {#each genres as genre, index (genre)}
function create_each_block$1(key_1, ctx) {
	var button, t0_value = ctx.genre, t0, t1, dispose;

	function click_handler() {
		return ctx.click_handler(ctx);
	}

	function func_1(...args) {
		return ctx.func_1(ctx, ...args);
	}

	return {
		key: key_1,

		first: null,

		c: function create() {
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t0 = claim_text(button_nodes, t0_value);
			t1 = claim_text(button_nodes, "\n        ");
			button_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(button, "class", "genre button svelte-j43c0x");
			toggle_class(button, "selected", ctx.$selectedGenres.some(func_1));
			add_location(button, file$h, 77, 8, 1754);
			dispose = listen(button, "click", click_handler);
			this.first = button;
		},

		m: function mount(target, anchor) {
			insert(target, button, anchor);
			append(button, t0);
			append(button, t1);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.$selectedGenres || changed.genres)) {
				toggle_class(button, "selected", ctx.$selectedGenres.some(func_1));
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(button);
			}

			dispose();
		}
	};
}

function create_fragment$h(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.$showGenreDialog) && create_if_block$3(ctx);

	return {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.$showGenreDialog) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let $showGenreDialog, $selectedGenres;

	validate_store(showGenreDialog, 'showGenreDialog');
	subscribe($$self, showGenreDialog, $$value => { $showGenreDialog = $$value; $$invalidate('$showGenreDialog', $showGenreDialog); });
	validate_store(selectedGenres, 'selectedGenres');
	subscribe($$self, selectedGenres, $$value => { $selectedGenres = $$value; $$invalidate('$selectedGenres', $selectedGenres); });

	
  const close = () => {
    showGenreDialog.set(false);
    selectedGenres.reset();
  };

	function func() {
		return showGenreDialog.set(false);
	}

	function click_handler({ genre }) {
		return selectedGenres.toggle(genre);
	}

	function func_1({ genre }, item) {
		return item === genre;
	}

	return {
		close,
		$showGenreDialog,
		$selectedGenres,
		func,
		click_handler,
		func_1
	};
}

class GenreDialog extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$h, safe_not_equal, []);
	}
}

/* src/App.svelte generated by Svelte v3.6.7 */

function create_fragment$i(ctx) {
	var t0, t1, t2, t3, current;

	var header = new Header({ $$inline: true });

	var main = new Main({ $$inline: true });

	var genredialog = new GenreDialog({ $$inline: true });

	var coverpreview = new CoverPreview({ $$inline: true });

	var footer = new Footer({ $$inline: true });

	return {
		c: function create() {
			header.$$.fragment.c();
			t0 = space();
			main.$$.fragment.c();
			t1 = space();
			genredialog.$$.fragment.c();
			t2 = space();
			coverpreview.$$.fragment.c();
			t3 = space();
			footer.$$.fragment.c();
		},

		l: function claim(nodes) {
			header.$$.fragment.l(nodes);
			t0 = claim_text(nodes, "\n");
			main.$$.fragment.l(nodes);
			t1 = claim_text(nodes, "\n");
			genredialog.$$.fragment.l(nodes);
			t2 = claim_text(nodes, "\n");
			coverpreview.$$.fragment.l(nodes);
			t3 = claim_text(nodes, "\n");
			footer.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			mount_component(main, target, anchor);
			insert(target, t1, anchor);
			mount_component(genredialog, target, anchor);
			insert(target, t2, anchor);
			mount_component(coverpreview, target, anchor);
			insert(target, t3, anchor);
			mount_component(footer, target, anchor);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);

			transition_in(main.$$.fragment, local);

			transition_in(genredialog.$$.fragment, local);

			transition_in(coverpreview.$$.fragment, local);

			transition_in(footer.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(header.$$.fragment, local);
			transition_out(main.$$.fragment, local);
			transition_out(genredialog.$$.fragment, local);
			transition_out(coverpreview.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(header, detaching);

			if (detaching) {
				detach(t0);
			}

			destroy_component(main, detaching);

			if (detaching) {
				detach(t1);
			}

			destroy_component(genredialog, detaching);

			if (detaching) {
				detach(t2);
			}

			destroy_component(coverpreview, detaching);

			if (detaching) {
				detach(t3);
			}

			destroy_component(footer, detaching);
		}
	};
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$i, safe_not_equal, []);
	}
}

/* src/routes/index.svelte generated by Svelte v3.6.7 */

function create_fragment$j(ctx) {
	var current;

	var app = new App({ $$inline: true });

	return {
		c: function create() {
			app.$$.fragment.c();
		},

		l: function claim(nodes) {
			app.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(app, target, anchor);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(app.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(app.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(app, detaching);
		}
	};
}

class Index$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$j, safe_not_equal, []);
	}
}

export default Index$1;
